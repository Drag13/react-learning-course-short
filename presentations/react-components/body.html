<section>
  <section>
    <h2>What is the component</h2>
  </section>

  <section>
    <h3>Component</h3>
    <p class="left">An independent unit of code that encapsulate single, logical functionality</p>
  </section>

  <section>

    <h3>From React prospective component </h3>
    <p class="left"> is a <i class="fragment highlight-current-green">function</i>
      or
      <i class="fragment highlight-current-green">class</i> that accepts
      <i class="fragment highlight-current-green">props (input)</i> and returns <i
        class="fragment highlight-current-green">JSX</i>
    </p>
  </section>

  <section>
    <h3>JSX/TSX - JavaScript XML</h3>
    <p class="left">HTML like syntax that is parsed and transformed to the regular JavaScript code</p>
  </section>

</section>

<section>
  <section>
    <h2>Why to use the components</h2>
  </section>

  <section>
    <h3>Reusing</h3>

    <p class="left">
      Components are very useful for re-using logic or styles. Create one component and use it across
      all over the application.
    </p>
  </section>

  <section>
    <h3>Example:</h3>

    <pre><code data-line-numbers="" class="language-tsx"><h2 class="header header2">What is the component</h2>
...
<h2 class="header header2">Why to use component</h2>
    </code></pre>

    <h3 class="fragment fade-up">VS</h3>

    <pre class="fragment fade-up"><code data-line-numbers  class="language-tsx">&lt;AppH2&gt;What is the component&lt;/AppH2&gt;
...
&lt;AppH2&gt;Why to use component&lt;/AppH2&gt;</code></pre>
  </section>

  <section>
    <h3>Reusing gives you</h3>

    <ul>
      <li class="fragment fade-up">Less mistakes</li>
      <li class="fragment fade-up">Speed up the coding</li>
      <li class="fragment fade-up">Better maintainability</li>
    </ul>
  </section>

  <section>
    <h3>Encapsulation</h3>

    <p class="left">Components hides complexity and the realization to make you deal with them as easy as possible</p>
  </section>

  <section>
    <h3>Example</h3>

    <pre><code class="language-tsx" data-line-numbers>const handleChange = (v: number) =&gt; console.log(v);
const App = () =&gt; {
  return (
    &lt;ComplexCounter initialValue={0} onChange={handleChange}/&gt;
  );
};
      </code></pre>
    </code></pre>
  </section>

  <section>
    <h3>Encapsulation gives you </h3>
    <ul>
      <li class="fragment">Much more easier maintenance</li>
      <li class="fragment fade-up">Better Developer experience</li>
    </ul>
  </section>

  <section>
    <h3>Readability</h3>

    <pre><code class="language-tsx" data-line-numbers>const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;AppNav /&gt;
      &lt;WeolcomeHeader /&gt;
      &lt;Avatar /&gt;
      &lt;Bio /&gt;
      &lt;Contacts /&gt;
      &lt;Footer /&gt;
    &lt;/&gt;
  );
};</code></pre>
  </section>

  <section>
    <h3>Testing</h3>

    <p class="left">
      It's much more easier to test a single, small component which has one or few responsibilities that the whole App
      Components are great for testing which increase maintainability.
    </p>

    <p class="left">Easier tests = less bugs and fragility</p>
  </section>

</section>

<section>
  <section>
    <h2>Component types</h2>
  </section>

  <section>
    <h3>Functional components</h3>

    <pre><code class="language-tsx" data-line-numbers>const App = () =&gt; {
  return &lt;h1&gt;Hello World&lt;/h1&gt;;
};
    </code></pre>

    <pre class="fragment fade-up"><code class="language-tsx" data-line-numbers>function App() {
  return &lt;h1&gt;Hello world&lt;/h1&gt;;
}
    </code></pre>
  </section>

  <section>

    <h3>
      Class Based components
    </h3>

    <pre><code class="language-tsx" data-line-numbers>import { PureComponent } from 'React';

class App extends PureComponent {
  render() {
    return &lt;h1&gt;Hello world&lt;/h1&gt;;
  }
}
</code></pre>

    <pre class="fragment fade-up"><code class="language-tsx" data-line-numbers>import { Component } from 'React';

class App extends Component {
  render() {
    return &lt;h1&gt;Hello world&lt;/h1&gt;;
  }
}
  </code></pre>
  </section>

  <section>
    <h3>The difference between FC and ClassBased Component</h3>

    <ul>
      <li>Nature - function VS class </li>
      <li class="fragment fade-up">The way we access state - this.setState() VS useState()</li>
      <li class="fragment fade-up">LifeCycle hooks - some of them are not accessible for the FC</li>
    </ul>
  </section>

  <section>
    <h3>Dumb Components eg. presentational</h3>

    <p class="left">Dumb components - has no state inside, they made only for being nice</p>

    <pre><code class="language-tsx" data-line-numbers>export const AppGreetings = () =&gt; {
  return &lt;h1 className="header header1"&gt;I am a nice header&lt;/h1&gt;;
};
</code></pre>

  </section>

  <section>
    <h3>Smart components - contains the state inside</h3>

    <pre><code data-line-numbers="1-14|1|4|8|9">import { useState } from "react";

const Expand = () =&gt; {
  const [isOpened, setExpanded] = useState(true);
  const style = { display: isOpened ? "block" : "none" };
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setExpanded(!isOpened)}&gt;
        {isOpened ? "Hide" : "Show}
      &lt;/button&gt;
      &lt;div style={style}&gt; VERY BIG TEXT &lt;/div&gt;
    &lt;/div&gt;
  );
};
                      </code></pre>
  </section>
</section>
<section>
  <section>
    <h2>How to pass data into the component</h2>
  </section>

  <section>
    <ul>
      <li>From <i>props</i> - should be preferred</li>
      <li class="fragment fade-up">From <i>context</i></li>
      <li class="fragment fade-up">Directly from the code</li>
    </ul>
  </section>

  <section>
    <h3>Using props - the most correct</h3>
    <pre>
        <code data-line-numbers="1-11|3|5|6|9">import { FC } from "react";

type H1Props = { userName: string };

const AppH1: FC &lt;H1Props&gt; = (props) => (
  <h1>Hello {props.userName}</h1>
);

export default () => &lt;AppH1 userName="Hello world" /&gt;
        </code>
    </pre>
  </section>

  <section>
    <h3>Passing another Component is also possible</h3>

    <pre><code class="language-tsx" data-line-numbers="1-9|1|3|6|9">import { FC, PropsWithChildren } from "react";

type Props = PropsWithChildren&lt;{}&gt;;

export const AppH1: FC&lt;Props&gt; = (props) =&gt; {
  return &lt;h1 className="header header1"&gt;{props.children}&lt;/h1&gt;;
};

const App = () =&gt; &lt;AppH1&gt;&lt;TranslatedText text="hello"/&gt;&lt;/AppH1&gt;</code></pre>
  </section>

  <section>
    <h3>Same way it works with class based component</h3>

    <pre><code class="language-tsx" data-line-numbers="1-8|6">import { PureComponent } from "react";

type Props = { text: string };
class AppH1 extends PureComponent&lt;Props&gt; {
  render() {
    return &lt;h1&gt;{this.props.text}&lt;/h1&gt;;
  }
}
</code></pre>
  </section>

  <section>
    <h3>About the context we will talk a bit later</h3>
  </section>

</section>

<section>
  <section>
    <h2>How to get data from the component</h2>
  </section>

  <section>
    <h4>Callback - the best option to get data from the component</h4>

    <pre>
    <code data-line-numbers="1-10|3|5|6|9">import { FC } from "react";

type BtnProps = { onClick: (val: string) => void };

const Btn: FC&lt;BtnProps&gt; = (props) => (
  &lt;button onClick={() => props.onClick("hello!")} /&gt;
);

&lt;Btn onClick={(v) => alert(v)} /&gt;
    </code>
</pre>
  </section>

  <section class="left">
    <strong>⚠️Important: </strong> Using anonymous functions as a callback might heart the performance
  </section>
</section>

<section>
  <section>
    <h2>Component lifecycle</h2>
  </section>

  <section>
    <div class="two-column">
      <div>
        <h3>Class Based</h3>
        <ul>
          <li class="fragment" data-fragment-index="1">Initialization</li>
          <li class="fragment" data-fragment-index="3">Render</li>
          <li class="fragment" data-fragment-index="5">ComponentDidMount</li>
          <li class="fragment" data-fragment-index="7">ShouldComponentUpdate</li>
          <li class="fragment" data-fragment-index="9">Render</li>
          <li class="fragment" data-fragment-index="11">ComponentDidUpdate</li>
          <li class="fragment" data-fragment-index="13">ComponentDidCatch</li>
          <li class="fragment" data-fragment-index="15">ComponentWillUnmount</li>
        </ul>
      </div>

      <div>
        <h3>Functional</h3>
        <ul>
          <li class="fragment" data-fragment-index="2"> - </li>
          <li class="fragment" data-fragment-index="4">function()</li>
          <li class="fragment" data-fragment-index="6">useEffect(, [])</li>
          <li class="fragment" data-fragment-index="8"> - </li>
          <li class="fragment" data-fragment-index="10">function() </li>
          <li class="fragment" data-fragment-index="12">useEffect()</li>
          <li class="fragment" data-fragment-index="14"> - </li>
          <li class="fragment" data-fragment-index="16">useEffect</li>
        </ul>
      </div>
    </div>
  </section>

  <section>
    <h3>What about others???</h3>

    <p class="left">Other hooks are either deprecated like componentWillMount either beyond this course for beginners
      like useLayoutEffect</p>
  </section>

  <section>
    <h3>Most useful are </h3>

    <ul>
      <li>ComponentDidMount for one time actions like fetching the server</li>
      <li class="fragment fade-up">ComponentDidUpdate for side effect</li>
      <li class="fragment fade-up">ComponentDidUnmount for cleanup</li>
    </ul>
  </section>

  <section>
    <h3>Functional example</h3>
    <pre><code class="language-tsx" data-line-numbers>export default function App() {
  useEffect(() =&gt; {
    console.log("fires each and every update");
  });

  useEffect(() =&gt; {
    console.log("fires once, upon did mount");
  }, []);

  useEffect(() =&gt; {
    return () =&gt; console.log("fires on component did unmount");
  });
  return &lt;&gt;Test&lt;/&gt;;
}
    </code></pre>
  </section>


  <section>
    <h3>Class Based example</h3>
    <pre><code class="language-tsx" data-line-numbers>export default class App extends Component {
  constructor(p: {}) { super(p); }
  render(){ return &lt;&gt;Test&lt;/&gt; }
  componentDidMount() {}
  shouldComponentUpdate(){ return true; }
  componentDidUpdate() {}
  componentDidCatch() {}
  componentWillUnmount() {}
}
    </code></pre>
  </section>

  <section>
    <h3>The importance of knowing component lifecycle</h3>

    <p class="left">
      Imagine you known nothing about the lifecycle and put fetch call inside the render. Each time your component will
      be re-rendered, each time you will fire request to the sever. Which will change the state, which will invoke one
      more re-render. Despair
    </p>
  </section>
</section>